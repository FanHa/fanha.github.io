## 版本
+ Github:redis/redis 
+ 分支:6.0 
+ 版本号:6.0.7

## 序
redis的多线程是把io操作分离出主线程事件循环,实际的命令操作依然是单(主)线程执行事件循环;

## 数据结构
```c
// src/server.h
struct redisServer {
    list *clients;              /* List of active clients */
    list *clients_to_close;     /* Clients to close asynchronously */
    list *clients_pending_write; /* There is to write or install handler. */
    list *clients_pending_read;  // 放准备分发给io线程区处理的可读事件内容
}
```
```c
// src/networking.c
list *io_threads_list[IO_THREADS_MAX_NUM]; 分给每个io线程去处理的任务队列
_Atomic unsigned long io_threads_pending[IO_THREADS_MAX_NUM]; // 每个io线程当前pending等待处理的事件数(应该是防止每次都要遍历list算这个数量)

```
## 初始化
```c
// src/server.c
void InitServerLast() {
    // ...
    initThreadedIO();
    // ...
}
```
```c
// src/networking.c
void initThreadedIO(void) {
    // ...

    for (int i = 0; i < server.io_threads_num; i++) {
        // 每一个io线程对应一个任务list
        io_threads_list[i] = listCreate();

        /* Things we do only for the additional threads. */
        pthread_t tid;
        pthread_mutex_init(&io_threads_mutex[i],NULL);
        io_threads_pending[i] = 0;
        pthread_mutex_lock(&io_threads_mutex[i]); /* Thread will be stopped. */
        // #ref(IOThreadMain)
        if (pthread_create(&tid,NULL,IOThreadMain,(void*)(long)i) != 0) {
            // ...
            exit(1);
        }
        io_threads[i] = tid;
    }
}
```

## 主线程事件循环收到一个可读事件的处理

### 将可读事件的内容添加到clients_pending_read队列里
```c
// src/networking.c
void readQueryFromClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    int nread, readlen;
    size_t qblen;

    // 开启了多线程io后,主线程的可读事件处理加了一层异步逻辑,
    // 先把可读事件转到一个队列里,然后在主循环的beforesleep阶段把这些可读事件转给io线程处理
    if (postponeClientRead(c)) return;
    // ...
}

int postponeClientRead(client *c) {
    if (server.io_threads_active &&
        server.io_threads_do_reads &&
        !ProcessingEventsWhileBlocked &&
        !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_PENDING_READ)))
    {
        c->flags |= CLIENT_PENDING_READ; //设置flag为CLIENT_PENDING_READ,下次io线程走到同一个流程时这个函数就会返回0,因而接着执行原本的可读事件流程
        listAddNodeHead(server.clients_pending_read,c); // 可读事件内容添加到clients_pending_read队列里,然后在主循环的beforesleep阶段分发给具体的io线程处理
        return 1;
    } else {
        return 0;
    }
}
```

### 主循环的beforesleep阶段分发clients_pending_read队列里的内容到io线程处理
```c
void beforeSleep(struct aeEventLoop *eventLoop) {
    // ...
    handleClientsWithPendingReadsUsingThreads();
    // ...
}

```
```c
// src/networking.c
int handleClientsWithPendingReadsUsingThreads(void) {

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_read,&li);
    int item_id = 0;
    while((ln = listNext(&li))) { // 将pending读事件里的任务平均分配给io线程
        client *c = listNodeValue(ln);
        int target_id = item_id % server.io_threads_num;
        listAddNodeTail(io_threads_list[target_id],c);
        item_id++;
    }

    // 纪录每个io线程pending处理的事件数
    io_threads_op = IO_THREADS_OP_READ;
    for (int j = 1; j < server.io_threads_num; j++) {
        int count = listLength(io_threads_list[j]);
        io_threads_pending[j] = count;
    }

    // 等待所有io线程处理完这次分配的任务才继续
    while(1) {
        unsigned long pending = 0;
        for (int j = 1; j < server.io_threads_num; j++)
            pending += io_threads_pending[j];
        if (pending == 0) break;
    }


    // 到这里,整个clients_pending_read队列里的可读事件已经由io线程们准备好了,可以开始正式的处理 processInputBuffer
    while(listLength(server.clients_pending_read)) {
        // ...
        processInputBuffer(c);
    }

    return processed;
}
```

### io子线程处理可读事件
```c
void *IOThreadMain(void *myid) {
    /* The ID is the thread number (from 0 to server.iothreads_num-1), and is
     * used by the thread to just manipulate a single sub-array of clients. */
    long id = (unsigned long)myid;
    char thdname[16];

    snprintf(thdname, sizeof(thdname), "io_thd_%ld", id);
    redis_set_thread_title(thdname);
    redisSetCpuAffinity(server.server_cpulist);

    while(1) {
        /* Wait for start */
        for (int j = 0; j < 1000000; j++) {
            if (io_threads_pending[id] != 0) break;
        }

        /* Give the main thread a chance to stop this thread. */
        if (io_threads_pending[id] == 0) {
            pthread_mutex_lock(&io_threads_mutex[id]);
            pthread_mutex_unlock(&io_threads_mutex[id]);
            continue;
        }

        serverAssert(io_threads_pending[id] != 0);

        if (tio_debug) printf("[%ld] %d to handle\n", id, (int)listLength(io_threads_list[id]));

        /* Process: note that the main thread will never touch our list
         * before we drop the pending count to 0. */
        listIter li;
        listNode *ln;
        listRewind(io_threads_list[id],&li);
        while((ln = listNext(&li))) {
            client *c = listNodeValue(ln);
            if (io_threads_op == IO_THREADS_OP_WRITE) {
                writeToClient(c,0);
            } else if (io_threads_op == IO_THREADS_OP_READ) {
                readQueryFromClient(c->conn);
            } else {
                serverPanic("io_threads_op value is unknown");
            }
        }
        listEmpty(io_threads_list[id]);
        io_threads_pending[id] = 0;

        if (tio_debug) printf("[%ld] Done\n", id);
    }
}

```