## 版本
+ Github:redis/redis 
+ 分支:6.0 
+ 版本号:6.0.7

## 从Redis的master信息初始化
```c
// src/server.c
int main(int argc, char **argv) {
    // ...
    loadDataFromDisk();
    // ...
}
void loadDataFromDisk(void) {
    // ...
            if ((server.masterhost ||
                (server.cluster_enabled &&
                nodeIsSlave(server.cluster->myself))) &&
                rsi.repl_id_is_set &&
                rsi.repl_offset != -1 &&
                rsi.repl_stream_db != -1)
            {
                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));
                server.master_repl_offset = rsi.repl_offset;
                // 当发现自己是slave时,执行replica相关的连接初始化信息
                // 注:这里只是初始化了连接所需要的信息,并没有真正与master连接,
                // 实际连接是通过redis的周期serverCron机制来连接并与master通信
                replicationCacheMasterUsingMyself();
                selectDb(server.cached_master,rsi.repl_stream_db);
            }
    // ...
}
```
```c
// src/replication.c
void replicationCacheMasterUsingMyself(void) {
    // 设置初始偏移量(redis 主从采用一个全量的版本 ReplicationId + 偏移量的方式)
    server.master_initial_offset = server.master_repl_offset;

    // 根据配置信息创建到master的client连接信息结构
    replicationCreateMasterClient(NULL,-1);

    // 设置replacationId
    memcpy(server.master->replid, server.replid, sizeof(server.replid));

    // 将创建的master连接信息转移给全局变量server.cached_master ??
    unlinkClient(server.master);
    server.cached_master = server.master;
    server.master = NULL;
}
```

## 从redis的 连接master 及信息交流
```c
// src/server.c
int main(int argc, char **argv) {
    // ...
    initServer();
    // ...
}
void initServer(void) {
    // ...
    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
        // ...
    }
    // ...
}

int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // ...
    // serverCron 设定了每1000毫秒执行一次replaca相关的操作
    run_with_period(1000) replicationCron();
    // ...
}
```

```c
// src/replication.c
// 周期地执行repleca逻辑
void replicationCron(void) {
    static long long replication_cron_loops = 0;

    // ...

    // 当与master的连接状态处于‘REPL_STATE_CONNECT’(初始化连接信息后就是这个状态)时,表示我们还没有实际连master,需要连一下
    if (server.repl_state == REPL_STATE_CONNECT) {
        // 执行与master的连接逻辑
        if (connectWithMaster() == C_OK) {
            serverLog(LL_NOTICE,"MASTER <-> REPLICA sync started");
        }
    }

    // 周期性的给master发ack信息
    if (server.masterhost && server.master &&
        !(server.master->flags & CLIENT_PRE_PSYNC))
        replicationSendAck();

    // 当前实例是另一个(批)实例的master时,需要执行的replica逻辑
    // ...
}

int connectWithMaster(void) {
    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();
    // 与master机器的连接过程交给了低层的linux机制(tcp握手,tls啥的都在这里),然后注册一个可写事件回调‘syncWithMaster’,连接完成后会调用此回调
    // 实际上,除了“连接完成”,后续的同步逻辑都使用这个函数syncWithMaster,函数内部根据当前的状态(server.repl_state)执行同步逻辑的不同阶段
    if (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,
                NET_FIRST_BIND_ADDR, syncWithMaster) == C_ERR) {
        //...
    }

    server.repl_transfer_lastio = server.unixtime;
    // 设置repl_state状态为正在连接中,这样回调函数‘syncWithMaster’调用时可以知道当前的状态,并执行相应逻辑
    server.repl_state = REPL_STATE_CONNECTING;
    return C_OK;
}

void syncWithMaster(connection *conn) {
    char tmpfile[256], *err = NULL;
    int dfd = -1, maxtries = 5;
    int psync_result;
    // ...

    // 新建的连接还没有经受住考验,需要ping一下看看效果
    if (server.repl_state == REPL_STATE_CONNECTING) {
        // 注册可读事件的回调,同样也是syncWithMaster
        connSetReadHandler(conn, syncWithMaster);
        // 取消可写事件的回调
        connSetWriteHandler(conn, NULL);
        // 修改repl_state为接受pong,当master返回回应pong时,触发可读事件的回调,就是上面注册的syncWithMaster
        server.repl_state = REPL_STATE_RECEIVE_PONG;
        // 向master发送ping
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"PING",NULL);
        if (err) goto write_error;
        return;
    }

    /* 前面设置了可读事件的回调,并把repl_state状态设置为了 ‘REPL_STATE_RECEIVE_PONG’,所以当收到master发挥的‘pong’信息时,会执行下面的逻辑
    if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
        // 读取master回的信息
        // 注:这个函数‘sendSynchronousCommand’名字中的‘send’带有迷惑性,其实里面是根据第一个参数 SYNC_CMD_READ | SYNC_CMD_WRITE来决定执行读逻辑还是写逻辑
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        // 收到了pong回应后,将repl_state状态改为‘REPL_STATE_SEND_AUTH’,紧接着下面的发送认证信息的代码
        server.repl_state = REPL_STATE_SEND_AUTH;
    }

    // 发送配置好的认证信息
    if (server.repl_state == REPL_STATE_SEND_AUTH) {
        if (server.masteruser && server.masterauth) {
            // 用户+“密钥”形式
            err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"AUTH",
                                         server.masteruser,server.masterauth,NULL);
            if (err) goto write_error;
            // 设置‘REPL_STATE_RECEIVE_AUTH’状态
            server.repl_state = REPL_STATE_RECEIVE_AUTH;
            return;
        } else if (server.masterauth) {
            // 只“密钥”形式
            err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"AUTH",server.masterauth,NULL);
            if (err) goto write_error;
            // 设置‘REPL_STATE_RECEIVE_AUTH’状态
            server.repl_state = REPL_STATE_RECEIVE_AUTH;
            return;
        } else {
            // 不需要发送认证信息时直接跳过认证状态到‘REPL_STATE_SEND_PORT’
            server.repl_state = REPL_STATE_SEND_PORT;
        }
    }

    // 可读事件的回调没变,所以master回应了auth结果后,代码会执行到这里
    if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {
        // 读取验证结果
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        if (err[0] == '-') {
            // ... 错误处理
        }
        sdsfree(err);
        // 验证通过将状态置换为‘REPL_STATE_SEND_PORT’
        server.repl_state = REPL_STATE_SEND_PORT;
    }

    // 发送slave这边的port信息
    if (server.repl_state == REPL_STATE_SEND_PORT) {
        // ...
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"REPLCONF",
                "listening-port",portstr, NULL);
        // ...
        // 设置状态‘REPL_STATE_RECEIVE_PORT’,等待接收master的回应
        server.repl_state = REPL_STATE_RECEIVE_PORT;
        return;
    }

    // 接收master对port信息的回应
    if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        // 下一个状态,发送IP,应该是redis实例可以设置多个IP
        server.repl_state = REPL_STATE_SEND_IP;
    }

    // ... 没有设置多余ip直接跳到下一个状态
    if (server.repl_state == REPL_STATE_SEND_IP &&
        server.slave_announce_ip == NULL)
    {
            server.repl_state = REPL_STATE_SEND_CAPA;
    }

    // slave的ip信息交流
    if (server.repl_state == REPL_STATE_SEND_IP) {
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"REPLCONF",
                "ip-address",server.slave_announce_ip, NULL);
        // ...
        server.repl_state = REPL_STATE_RECEIVE_IP;
        return;
    }

    if (server.repl_state == REPL_STATE_RECEIVE_IP) {
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        server.repl_state = REPL_STATE_SEND_CAPA;
    }

    // 告诉master我支持哪些同步方式
    if (server.repl_state == REPL_STATE_SEND_CAPA) {
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"REPLCONF",
                "capa","eof","capa","psync2",NULL);
        // ...
        server.repl_state = REPL_STATE_RECEIVE_CAPA;
        return;
    }
    if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        server.repl_state = REPL_STATE_SEND_PSYNC;
    }

    // 正式发sync请求到master
    if (server.repl_state == REPL_STATE_SEND_PSYNC) {
        if (slaveTryPartialResynchronization(conn,0) == PSYNC_WRITE_ERROR) {
            err = sdsnew("Write error sending the PSYNC command.");
            goto write_error;
        }
        server.repl_state = REPL_STATE_RECEIVE_PSYNC;
        return;
    }

    // 保守的错误判断,执行到这里不应该是别的状态
    if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {
        // ...
    }

    // 尝试获取master传过来的同步信息,如果数据还没有准备好(即psync_result == PSYNC_WAIT_REPLY),则return,等待下一个可读事件
    psync_result = slaveTryPartialResynchronization(conn,1);
    if (psync_result == PSYNC_WAIT_REPLY) return; /* Try again later... */

    // 错误之一
    if (psync_result == PSYNC_TRY_LATER) goto error;

    // 成功的执行P(分步)Sync
    if (psync_result == PSYNC_CONTINUE) {
        serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Master accepted a Partial Resynchronization.");
        // ...
        return;
    }

    // 代码执行到这里代表与master的同步失败了,需要把当前实例的slave的连接也重制
    disconnectSlaves(); /* Force our slaves to resync with us as well. */
    freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */

    // 当P(分步)Sync不支持时,需要使用(全量)Sync方式
    if (psync_result == PSYNC_NOT_SUPPORTED) {
        serverLog(LL_NOTICE,"Retrying with SYNC...");
        if (connSyncWrite(conn,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
            // ...
            goto error;
        }
    }

    // 全量Sync数据比较多,需要准备一块地方撞门方这些数据
    if (!useDisklessLoad()) {
        while(maxtries--) {
            snprintf(tmpfile,256,
                "temp-%d.%ld.rdb",(int)server.unixtime,(long int)getpid());
            dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
            if (dfd != -1) break;
            sleep(1);
        }
        if (dfd == -1) {
            // ...
            goto error;
        }
        server.repl_transfer_tmpfile = zstrdup(tmpfile);
        server.repl_transfer_fd = dfd;
    }

    // 设置全量Sync,可读事件的新处理函数‘readSyncBulkPayload’
    if (connSetReadHandler(conn, readSyncBulkPayload)
            == C_ERR)
    {
        // ...
    }

    server.repl_state = REPL_STATE_TRANSFER;
    server.repl_transfer_size = -1;
    server.repl_transfer_read = 0;
    server.repl_transfer_last_fsync_off = 0;
    server.repl_transfer_lastio = server.unixtime;
    return;

error:
    // ...
    return;

write_error: /* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
    // ...
    goto error;
}
```
### sendSynchronousCommand 向master收发信息
前面与master基本信息交互都是通过sendSynchronousCommand来实现
>注:这里的‘sync'指的是调用内核,不是指master接收到信息并返回结果

### slaveTryPartialResynchronization
```c
// src/replication.c
// 与master进行Psync分步同步,第二个参数表示是读还是写消息
int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    char *psync_replid;
    char psync_offset[32];
    sds reply;

    // 当是要写消息时(即向master发送请求,表示自己要获取master的数据)
    if (!read_reply) {
        server.master_initial_offset = -1;
        // 目前的redis是把master信息存在一个cached_master的全局变量(原因??)
        if (server.cached_master) {
            psync_replid = server.cached_master->replid;
            snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
            // ...
        } else {
            // ...
        }

        /* 向master发送psync命令,带上自己的replicationId 和 数据偏移量offset
        reply = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"PSYNC",psync_replid,psync_offset,NULL);
        if (reply != NULL) {
            // ...
        }
        // 返回状态’PSYNC_WAIT_REPLY‘,这样外层调用方就知道自己当前状态是要等待master的数据
        return PSYNC_WAIT_REPLY;
    }

    // 下面是读数据的逻辑
    // 向内核查询是否有master传来的消息
    reply = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
    if (sdslen(reply) == 0) {
        sdsfree(reply);
        // 返回PSYNC_WAIT_REPLY状态,继续等待master的消息
        return PSYNC_WAIT_REPLY;
    }
    // 为避免在处理传过来的数据时,又有新的数据从master传过来了,先讲readHandler置为null
    // ?? 如果这个时候真的有数据传来,会发生啥?
    connSetReadHandler(conn, NULL);

    // 当master返回FULLRESync时,表示因为“某些原因”以前的数据不怎么可靠了,需要重新全量同步
    if (!strncmp(reply,"+FULLRESYNC",11)) {
        char *replid = NULL, *offset = NULL;

        // 获取新的replicationId 和 offset(从master传来的信息里获取)
        replid = strchr(reply,' ');
        if (replid) {
            replid++;
            offset = strchr(replid,' ');
            if (offset) offset++;
        }
        if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
            serverLog(LL_WARNING,
            // master信息不合格时的处理
        } else {
            // 初始化本地的replicationId 和 offset信息
            memcpy(server.master_replid, replid, offset-replid-1);
            server.master_replid[CONFIG_RUN_ID_SIZE] = '\0';
            server.master_initial_offset = strtoll(offset,NULL,10);
        }
        // 全量同步了,不需要cachedMaster来保留分步传过来的信息了
        replicationDiscardCachedMaster();
        sdsfree(reply);
        // 告诉外面调用层,切换为PSYNC_FULLRESYNC状态
        return PSYNC_FULLRESYNC;
    }

    // 分部同步的逻辑
    if (!strncmp(reply,"+CONTINUE",9)) {
        // 取出master传来的replicationId
        char *start = reply+10;
        char *end = reply+9;
        while(end[0] != '\r' && end[0] != '\n' && end[0] != '\0') end++;
        if (end-start == CONFIG_RUN_ID_SIZE) {
            char new[CONFIG_RUN_ID_SIZE+1];
            memcpy(new,start,CONFIG_RUN_ID_SIZE);
            new[CONFIG_RUN_ID_SIZE] = '\0';

            // 比较master传来的replicationId 与 本地保存的replicationId
            if (strcmp(new,server.cached_master->replid)) {
                // 更新本地master的replicationId信息
                memcpy(server.replid2,server.cached_master->replid,
                    sizeof(server.replid2));
                server.second_replid_offset = server.master_repl_offset+1;
                memcpy(server.replid,new,sizeof(server.replid));
                memcpy(server.cached_master->replid,new,sizeof(server.replid));

                // 断开自己的slaves的连接, 相当于通知自己的slaves ReplicationId变了
                disconnectSlaves();
            }
        }

        /* Setup the replication to continue. */
        sdsfree(reply);
        replicationResurrectCachedMaster(conn);

        /* If this instance was restarted and we read the metadata to
         * PSYNC from the persistence file, our replication backlog could
         * be still not initialized. Create it. */
        if (server.repl_backlog == NULL) createReplicationBacklog();
        return PSYNC_CONTINUE;
    }

    /* If we reach this point we received either an error (since the master does
     * not understand PSYNC or because it is in a special state and cannot
     * serve our request), or an unexpected reply from the master.
     *
     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise
     * return PSYNC_TRY_LATER if we believe this is a transient error. */

    if (!strncmp(reply,"-NOMASTERLINK",13) ||
        !strncmp(reply,"-LOADING",8))
    {
        serverLog(LL_NOTICE,
            "Master is currently unable to PSYNC "
            "but should be in the future: %s", reply);
        sdsfree(reply);
        return PSYNC_TRY_LATER;
    }

    if (strncmp(reply,"-ERR",4)) {
        /* If it's not an error, log the unexpected event. */
        serverLog(LL_WARNING,
            "Unexpected reply to PSYNC from master: %s", reply);
    } else {
        serverLog(LL_NOTICE,
            "Master does not support PSYNC or is in "
            "error state (reply: %s)", reply);
    }
    sdsfree(reply);
    replicationDiscardCachedMaster();
    return PSYNC_NOT_SUPPORTED;
}

```
### replicationResurrectCachedMaster
### 从机器的replica状态图
### readSyncBulkPayload

