## 版本
+ Github:redis/redis 
+ 分支:6.0 
+ 版本号:6.0.7

## ReplicaRedis的master信息初始化
```c
// src/server.c
int main(int argc, char **argv) {
    // ...
    loadDataFromDisk();
    // ...
}
void loadDataFromDisk(void) {
    // ...
            if ((server.masterhost ||
                (server.cluster_enabled &&
                nodeIsSlave(server.cluster->myself))) &&
                rsi.repl_id_is_set &&
                rsi.repl_offset != -1 &&
                rsi.repl_stream_db != -1)
            {
                memcpy(server.replid,rsi.repl_id,sizeof(server.replid));
                server.master_repl_offset = rsi.repl_offset;
                // 当发现自己是slave时,执行replica相关的连接初始化信息
                // 注:这里只是初始化了连接所需要的信息,并没有真正与master连接,
                // 实际连接是通过redis的周期serverCron机制来连接并与master通信
                replicationCacheMasterUsingMyself();
                selectDb(server.cached_master,rsi.repl_stream_db);
            }
    // ...
}
```
```c
// src/replication.c
void replicationCacheMasterUsingMyself(void) {
    // 设置初始偏移量(redis 主从采用一个全量的版本 ReplicationId + 偏移量的方式)
    server.master_initial_offset = server.master_repl_offset;

    // 根据配置信息创建到master的client连接信息结构
    replicationCreateMasterClient(NULL,-1);

    // 设置replacationId
    memcpy(server.master->replid, server.replid, sizeof(server.replid));

    // 将创建的master连接信息转移给全局变量server.cached_master ??
    unlinkClient(server.master);
    server.cached_master = server.master;
    server.master = NULL;
}
```

## 从redis的 连接master 及信息交流
```c
// src/server.c
int main(int argc, char **argv) {
    // ...
    initServer();
    // ...
}
void initServer(void) {
    // ...
    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
        // ...
    }
    // ...
}

int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // ...
    // serverCron 设定了每1000毫秒执行一次replaca相关的操作
    run_with_period(1000) replicationCron();
    // ...
}
```

```c
// src/replication.c
// 周期地执行repleca逻辑
void replicationCron(void) {
    static long long replication_cron_loops = 0;

    // ...

    // 当与master的连接状态处于‘REPL_STATE_CONNECT’(初始化连接信息后就是这个状态)时,表示我们还没有实际连master,需要连一下
    if (server.repl_state == REPL_STATE_CONNECT) {
        // 执行与master的连接逻辑
        if (connectWithMaster() == C_OK) {
            serverLog(LL_NOTICE,"MASTER <-> REPLICA sync started");
        }
    }

    // 周期性的给master发ack信息
    if (server.masterhost && server.master &&
        !(server.master->flags & CLIENT_PRE_PSYNC))
        replicationSendAck();

    // 当前实例是另一个(批)实例的master时,需要执行的replica逻辑
    // ...
}

int connectWithMaster(void) {
    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();
    // 与master机器的连接过程交给了低层的linux机制(tcp握手,tls啥的都在这里),然后注册一个可写事件回调‘syncWithMaster’,连接完成后会调用此回调
    // 实际上,除了“连接完成”,后续的同步逻辑都使用这个函数syncWithMaster,函数内部根据当前的状态(server.repl_state)执行同步逻辑的不同阶段
    if (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,
                NET_FIRST_BIND_ADDR, syncWithMaster) == C_ERR) {
        //...
    }

    server.repl_transfer_lastio = server.unixtime;
    // 设置repl_state状态为正在连接中,这样回调函数‘syncWithMaster’调用时可以知道当前的状态,并执行相应逻辑
    server.repl_state = REPL_STATE_CONNECTING;
    return C_OK;
}

void syncWithMaster(connection *conn) {
    char tmpfile[256], *err = NULL;
    int dfd = -1, maxtries = 5;
    int psync_result;
    // ...

    // 新建的连接还没有经受住考验,需要ping一下看看效果
    if (server.repl_state == REPL_STATE_CONNECTING) {
        // 注册可读事件的回调,同样也是syncWithMaster
        connSetReadHandler(conn, syncWithMaster);
        // 取消可写事件的回调
        connSetWriteHandler(conn, NULL);
        // 修改repl_state为接受pong,当master返回回应pong时,触发可读事件的回调,就是上面注册的syncWithMaster
        server.repl_state = REPL_STATE_RECEIVE_PONG;
        // 向master发送ping
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"PING",NULL);
        if (err) goto write_error;
        return;
    }

    /* 前面设置了可读事件的回调,并把repl_state状态设置为了 ‘REPL_STATE_RECEIVE_PONG’,所以当收到master发挥的‘pong’信息时,会执行下面的逻辑
    if (server.repl_state == REPL_STATE_RECEIVE_PONG) {
        // 读取master回的信息
        // 注:这个函数‘sendSynchronousCommand’名字中的‘send’带有迷惑性,其实里面是根据第一个参数 SYNC_CMD_READ | SYNC_CMD_WRITE来决定执行读逻辑还是写逻辑
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        // 收到了pong回应后,将repl_state状态改为‘REPL_STATE_SEND_AUTH’,紧接着下面的发送认证信息的代码
        server.repl_state = REPL_STATE_SEND_AUTH;
    }

    // 发送配置好的认证信息
    if (server.repl_state == REPL_STATE_SEND_AUTH) {
        if (server.masteruser && server.masterauth) {
            // 用户+“密钥”形式
            err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"AUTH",
                                         server.masteruser,server.masterauth,NULL);
            if (err) goto write_error;
            // 设置‘REPL_STATE_RECEIVE_AUTH’状态
            server.repl_state = REPL_STATE_RECEIVE_AUTH;
            return;
        } else if (server.masterauth) {
            // 只“密钥”形式
            err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"AUTH",server.masterauth,NULL);
            if (err) goto write_error;
            // 设置‘REPL_STATE_RECEIVE_AUTH’状态
            server.repl_state = REPL_STATE_RECEIVE_AUTH;
            return;
        } else {
            // 不需要发送认证信息时直接跳过认证状态到‘REPL_STATE_SEND_PORT’
            server.repl_state = REPL_STATE_SEND_PORT;
        }
    }

    // 可读事件的回调没变,所以master回应了auth结果后,代码会执行到这里
    if (server.repl_state == REPL_STATE_RECEIVE_AUTH) {
        // 读取验证结果
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        if (err[0] == '-') {
            // ... 错误处理
        }
        sdsfree(err);
        // 验证通过将状态置换为‘REPL_STATE_SEND_PORT’
        server.repl_state = REPL_STATE_SEND_PORT;
    }

    // 发送slave这边的port信息
    if (server.repl_state == REPL_STATE_SEND_PORT) {
        // ...
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"REPLCONF",
                "listening-port",portstr, NULL);
        // ...
        // 设置状态‘REPL_STATE_RECEIVE_PORT’,等待接收master的回应
        server.repl_state = REPL_STATE_RECEIVE_PORT;
        return;
    }

    // 接收master对port信息的回应
    if (server.repl_state == REPL_STATE_RECEIVE_PORT) {
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        // 下一个状态,发送IP,应该是redis实例可以设置多个IP
        server.repl_state = REPL_STATE_SEND_IP;
    }

    // ... 没有设置多余ip直接跳到下一个状态
    if (server.repl_state == REPL_STATE_SEND_IP &&
        server.slave_announce_ip == NULL)
    {
            server.repl_state = REPL_STATE_SEND_CAPA;
    }

    // slave的ip信息交流
    if (server.repl_state == REPL_STATE_SEND_IP) {
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"REPLCONF",
                "ip-address",server.slave_announce_ip, NULL);
        // ...
        server.repl_state = REPL_STATE_RECEIVE_IP;
        return;
    }

    if (server.repl_state == REPL_STATE_RECEIVE_IP) {
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        server.repl_state = REPL_STATE_SEND_CAPA;
    }

    // 告诉master我支持哪些同步方式
    if (server.repl_state == REPL_STATE_SEND_CAPA) {
        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"REPLCONF",
                "capa","eof","capa","psync2",NULL);
        // ...
        server.repl_state = REPL_STATE_RECEIVE_CAPA;
        return;
    }
    if (server.repl_state == REPL_STATE_RECEIVE_CAPA) {
        err = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
        // ...
        server.repl_state = REPL_STATE_SEND_PSYNC;
    }

    // 正式发sync请求到master
    if (server.repl_state == REPL_STATE_SEND_PSYNC) {
        if (slaveTryPartialResynchronization(conn,0) == PSYNC_WRITE_ERROR) {
            err = sdsnew("Write error sending the PSYNC command.");
            goto write_error;
        }
        server.repl_state = REPL_STATE_RECEIVE_PSYNC;
        return;
    }

    // 保守的错误判断,执行到这里不应该是别的状态
    if (server.repl_state != REPL_STATE_RECEIVE_PSYNC) {
        // ...
    }

    // 尝试获取master传过来的同步信息,如果数据还没有准备好(即psync_result == PSYNC_WAIT_REPLY),则return,等待下一个可读事件
    psync_result = slaveTryPartialResynchronization(conn,1);
    if (psync_result == PSYNC_WAIT_REPLY) return; /* Try again later... */

    // 错误之一
    if (psync_result == PSYNC_TRY_LATER) goto error;

    // 成功的执行P(增量)Sync,返回,等待下一次同步
    if (psync_result == PSYNC_CONTINUE) {
        // ...
        return;
    }

    // 代码执行到这里代表与master的同步失败了,需要把当前实例的slave的连接也重制
    disconnectSlaves(); /* Force our slaves to resync with us as well. */
    freeReplicationBacklog(); /* Don't allow our chained slaves to PSYNC. */

    // 当P(增量)Sync不支持时,需要使用(全量)Sync方式,即向master发送SYNC命令
    if (psync_result == PSYNC_NOT_SUPPORTED) {
        serverLog(LL_NOTICE,"Retrying with SYNC...");
        if (connSyncWrite(conn,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
            // ...
            goto error;
        }
    }

    // 全量Sync数据比较多,如果没有设置diskless属性,需要准备一块空间专门这些数据
    if (!useDisklessLoad()) {
        while(maxtries--) {
            snprintf(tmpfile,256,
                "temp-%d.%ld.rdb",(int)server.unixtime,(long int)getpid());
            // 打开一个存放临时数据的文件
            dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
            if (dfd != -1) break;
            sleep(1);
        }
        if (dfd == -1) {
            // ...
            goto error;
        }
        server.repl_transfer_tmpfile = zstrdup(tmpfile);
        // 后续用这个repl_transer_fd全局变量来把master发过来的数据存进去
        server.repl_transfer_fd = dfd;
    }

    // 设置全量Sync,可读事件的新处理函数‘readSyncBulkPayload’
    if (connSetReadHandler(conn, readSyncBulkPayload)
            == C_ERR)
    {
        // ...
    }

    server.repl_state = REPL_STATE_TRANSFER;
    server.repl_transfer_size = -1; // 这个repl_transfer_size全局变量代表全量同步的数据还没有完全传过来,需要继续读和存数据;
    server.repl_transfer_read = 0;
    server.repl_transfer_last_fsync_off = 0;
    server.repl_transfer_lastio = server.unixtime;
    return;

error:
    // ...
    return;

write_error: /* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */
    // ...
    goto error;
}
```
### sendSynchronousCommand 向master收发信息
前面与master基本信息交互都是通过sendSynchronousCommand来实现
>注:这里的‘sync'指的是调用内核,不是指master接收到信息并返回结果

### slaveTryPartialResynchronization 增量同步
增量同步就是每次收到从master发过来的数据信息都及时执行和更新本地数据
```c
// src/replication.c
// 与master进行Psync增量同步,第二个参数表示是读还是写消息
int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    char *psync_replid;
    char psync_offset[32];
    sds reply;

    // 当是要写消息时(即向master发送请求,表示自己要获取master的数据)
    if (!read_reply) {
        server.master_initial_offset = -1;
        // 目前的redis是把master信息存在一个cached_master的全局变量(原因??)
        if (server.cached_master) {
            psync_replid = server.cached_master->replid;
            snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
            // ...
        } else {
            // ...
        }

        /* 向master发送psync命令,带上自己的replicationId 和 数据偏移量offset
        reply = sendSynchronousCommand(SYNC_CMD_WRITE,conn,"PSYNC",psync_replid,psync_offset,NULL);
        if (reply != NULL) {
            // ...
        }
        // 返回状态’PSYNC_WAIT_REPLY‘,这样外层调用方就知道自己当前状态是要等待master的数据
        return PSYNC_WAIT_REPLY;
    }

    // 下面是读数据的逻辑
    // 向内核查询是否有master传来的消息
    reply = sendSynchronousCommand(SYNC_CMD_READ,conn,NULL);
    if (sdslen(reply) == 0) {
        sdsfree(reply);
        // 返回PSYNC_WAIT_REPLY状态,继续等待master的消息
        return PSYNC_WAIT_REPLY;
    }
    // 为避免在处理传过来的数据时,又有新的数据从master传过来了,先讲readHandler置为null
    // ?? 如果这个时候真的有数据传来,会发生啥?
    connSetReadHandler(conn, NULL);

    // 当master返回FULLRESync时,需要重新全量同步,比如第一次同步就是要先全量同步
    if (!strncmp(reply,"+FULLRESYNC",11)) {
        char *replid = NULL, *offset = NULL;

        // 获取新的replicationId 和 offset(从master传来的信息里获取)
        replid = strchr(reply,' ');
        if (replid) {
            replid++;
            offset = strchr(replid,' ');
            if (offset) offset++;
        }
        if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
            serverLog(LL_WARNING,
            // master信息不合格时的处理
        } else {
            // 初始化本地的replicationId 和 offset信息
            memcpy(server.master_replid, replid, offset-replid-1);
            server.master_replid[CONFIG_RUN_ID_SIZE] = '\0';
            server.master_initial_offset = strtoll(offset,NULL,10);
        }
        // 全量同步了,不需要cachedMaster来保留分步传过来的信息了
        replicationDiscardCachedMaster();
        sdsfree(reply);
        // 告诉外面调用层,切换为PSYNC_FULLRESYNC状态
        return PSYNC_FULLRESYNC;
    }

    // 增量同步的逻辑
    if (!strncmp(reply,"+CONTINUE",9)) {
        // 取出master传来的replicationId
        char *start = reply+10;
        char *end = reply+9;
        while(end[0] != '\r' && end[0] != '\n' && end[0] != '\0') end++;
        if (end-start == CONFIG_RUN_ID_SIZE) {
            char new[CONFIG_RUN_ID_SIZE+1];
            memcpy(new,start,CONFIG_RUN_ID_SIZE);
            new[CONFIG_RUN_ID_SIZE] = '\0';

            // 比较master传来的replicationId 与 本地保存的replicationId
            if (strcmp(new,server.cached_master->replid)) {
                // 更新本地master的replicationId信息
                memcpy(server.replid2,server.cached_master->replid,
                    sizeof(server.replid2));
                server.second_replid_offset = server.master_repl_offset+1;
                memcpy(server.replid,new,sizeof(server.replid));
                memcpy(server.cached_master->replid,new,sizeof(server.replid));

                // 断开自己的slaves的连接, 相当于通知自己的slaves ReplicationId变了
                disconnectSlaves();
            }
        }

        // cachedMaster只是前期用来交互信息,进入增量同步阶段后,需要重新设置一些配置,比如可读事件的回调,
        // 下方函数详情
        replicationResurrectCachedMaster(conn);

        if (server.repl_backlog == NULL) createReplicationBacklog();
        return PSYNC_CONTINUE;
    }
    // ... 其他错误处理
}

```
#### replicationResurrectCachedMaster
```c
// src/replication.c
void replicationResurrectCachedMaster(connection *conn) {
    // 进入正式的sync阶段后,需要把master连接信息从全局变量cached_master切回master(意义在哪里??)
    server.master = server.cached_master;
    server.cached_master = NULL;
    server.master->conn = conn;
    connSetPrivateData(server.master->conn, server.master);
    server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master->authenticated = 1;
    server.master->lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;
    server.repl_down_since = 0;

    linkClient(server.master);
    // 设置master连接的可读事件,为readQueryFromClient函数;
    // readQueryFromClient函数,也是其他程序向redis发命令的标准连接的可读事件回调;
    // 此时redis就像执行其他客户端的命令一样接收并执行来自master的命令
    if (connSetReadHandler(server.master->conn, readQueryFromClient)) {
        // ...
    }

    // 设置可写事件回调sendReplyToClient(增量同步过程中肯定有需要向master发送一些信息的时候)
    if (clientHasPendingReplies(server.master)) {
        if (connSetWriteHandler(server.master->conn, sendReplyToClient)) {
            // ...
        }
    }
}
```

### readSyncBulkPayload 全量同步
全量同步并不是一次要把所有数据都读过来,是每次master连接有可读事件时就保存一部分,经过一些次数后,全量同步的数据全部传过来了,再做统一处理
```c
// src/replication.c
void readSyncBulkPayload(connection *conn) {
    // ...

    // repl_transfer_size 为-1时代表全量同步的数据长度信息还未知,需要先解析这个信息
    if (server.repl_transfer_size == -1) {
        // 读取这次从master传过来的数据段
        if (connSyncReadLine(conn,buf,1024,server.repl_syncio_timeout*1000) == -1) {
            // ...
            goto error;
        }
        // 从读过来的信息中窥探可能的错误,及处理
        if (buf[0] == '-') {
            // ...
            goto error;
        } else if (buf[0] == '\0') {
            // ...
            // 更新下统计信息
            server.repl_transfer_lastio = server.unixtime;
            return;
        } else if (buf[0] != '$') {
            // ...
            goto error;
        }

        // 全量同步的数据段有两种数据格式,
        // 一种是master知道要传多少数据,数据的前面一部分代表数据长度,
        // 另一种是master也不知道要传多少数据(diskless),传了个eof:<分隔符>

        if (strncmp(buf+1,"EOF:",4) == 0 && strlen(buf+5) >= CONFIG_RUN_ID_SIZE) {
            usemark = 1;
            memcpy(eofmark,buf+5,CONFIG_RUN_ID_SIZE); // 保存分隔符
            memset(lastbytes,0,CONFIG_RUN_ID_SIZE);
            server.repl_transfer_size = 0; // 不能从这次master传来的数据得到数据的大小,先置为0
            // ...
        } else {
            usemark = 0;
            server.repl_transfer_size = strtol(buf+1,NULL,10); // 得到master将要传过来的数据大小
            // ...
        }
        return;
    }

    // 当前服务没有使用diskless时(既获得的数据需要先存到磁盘里)
    if (!use_diskless_load) {
        if (usemark) { // 当master没有传数据长度信息时, 设置本次readlen 为 传过来的buf长度
            readlen = sizeof(buf);
        } else {
            // 当设置了本次数据长度时, 设置readlen
            left = server.repl_transfer_size - server.repl_transfer_read;
            readlen = (left < (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
        }

        // 读取可读事件中的数据
        nread = connRead(conn,buf,readlen);
        if (nread <= 0) {
            // ...
        }
        server.stat_net_input_bytes += nread;

        // 前面的“eof”型数据需要检测这次数据里是否包含eof后面的分隔符作为结尾,
        int eof_reached = 0;
        if (usemark) {
            if (nread >= CONFIG_RUN_ID_SIZE) {
                memcpy(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,
                       CONFIG_RUN_ID_SIZE);
            } else {
                int rem = CONFIG_RUN_ID_SIZE-nread;
                memmove(lastbytes,lastbytes+nread,rem);
                memcpy(lastbytes+rem,buf,nread);
            }
            if (memcmp(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == 0)
                // 本次数据带分隔符结尾
                eof_reached = 1;
        }

        // 更新时间信息,并将数据写入本地用来保存master数据的文件fd
        server.repl_transfer_lastio = server.unixtime;
        if ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) {
            // ...
        }
        server.repl_transfer_read += nread;

        if (usemark && eof_reached) {
            // 数据里带有eof分隔符时,需要把写入文件的数据裁剪掉分隔符的部分
            if (ftruncate(server.repl_transfer_fd,
                server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == -1)
            {
                // ...
            }
        }

        // 前面的数据都只是写到了内存里,主动调用fsync将每次获取的数据落盘,分摊一次性落盘带来的性能损耗和服务停滞
        if (server.repl_transfer_read >=
            server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)
        {
            off_t sync_size = server.repl_transfer_read -
                              server.repl_transfer_last_fsync_off;
            rdb_fsync_range(server.repl_transfer_fd,
                server.repl_transfer_last_fsync_off, sync_size);
            server.repl_transfer_last_fsync_off += sync_size;
        }

        // eof类型的数据没遇到分隔符时(此段数据没有结束),需要return,等待下一次继续读数据,把数据读完才进入下一个阶段
        if (!eof_reached) return;
    }

    // 暂停aof机制
    if (server.aof_state != AOF_OFF) stopAppendOnly();

    // 当使用diskless选项时,需要备份当前db里的数据,
    if (use_diskless_load &&
        server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)
    {
        diskless_load_backup = disklessLoadMakeBackups();
    }
    // 清空当前db里的内容
    emptyDb(-1,empty_db_flags,replicationEmptyDbCallback);

    // 暂时屏蔽可读事件的handler
    connSetReadHandler(conn, NULL);
    rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
    // 使用diskless属性时,直接将数据从conn加载到db里
    if (use_diskless_load) {
        rio rdb;
        rioInitWithConn(&rdb,conn,server.repl_transfer_size);

        //...
        // 加载数据到本地rdb
        if (rdbLoadRio(&rdb,RDBFLAGS_REPLICATION,&rsi) != C_OK) {
            // ...
        }
        stopLoading(1);

        if (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) {
            // 删除备份数据
            disklessLoadRestoreBackups(diskless_load_backup,0,empty_db_flags);
        }
        // ...
    } else { // 到这一步说明master的数据已经加载到了本地的一个rdb格式的文件里
        // 防止在加载master数据的同时在执行rdb备份数据
        if (server.rdb_child_pid != -1) {
            killRDBChild();
        }

        // 用master传过来的rdb文件代替原有的rdb文件
        int old_rdb_fd = open(server.rdb_filename,O_RDONLY|O_NONBLOCK);
        if (rename(server.repl_transfer_tmpfile,server.rdb_filename) == -1) {
            // ...
        }
        if (old_rdb_fd != -1) bioCreateBackgroundJob(BIO_CLOSE_FILE,(void*)(long)old_rdb_fd,NULL,NULL);

        // 走正常加载rdb文件到本地db的流程
        if (rdbLoad(server.rdb_filename,&rsi,RDBFLAGS_REPLICATION) != C_OK) {
            // ...
        }
        // ...
    }

    // 建立与master的连接,这样masterRedis就可以向正常用户连接一样发送redis命令指挥replicaRedis做事了
    replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);
    // 修改reli_state阶段REPL_STATE_CONNECTED,则下一次进入syncWithMaster时会重新尝试PSYNC方式获取数据
    server.repl_state = REPL_STATE_CONNECTED;
    server.repl_down_since = 0;

    // 重启本地aof机制
    if (server.aof_enabled) restartAOFAfterSYNC();
    return;

error:
    cancelReplicationHandshake();
    return;
}

```

## MasterRedis 角度

