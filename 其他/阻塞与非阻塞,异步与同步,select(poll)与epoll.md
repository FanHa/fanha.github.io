## 前言
一个IO操作涉及到应用层和内核层,一般情况下,所有IO数据都需要经过内核层,而应用层不能不直接操作内核层,需要向内核层发送请求操作(读操作要先把内核层的数据拷贝到应用层,写操作要把应用层的数据拷贝到内核层).
### 读操作
+   应用层向内核层请求读取某数据.
+   内核层收到应用层请求,检查数据是否已准备好(具体到网络IO就是网络对面传来的数据是否已经到内核了),如果数据已准备好,就将数据从内核层拷贝到指定的应用层,然后返回成功给应用层.
+   应用层得到了内核层已经把数据拷贝到自己可以控制的应用层,就可以应用这些数据了.

### 写操作
+   应用层向内核层请求写某数据到某个地方(可能是磁盘,网卡等等).
+   内核层检查这个请求写的目的地的写缓存区域是否可用,如果可用就返回通知应用层.
+   应用层收到通知后,将要写的数据拷贝到内核层.
> 注:对于应用程序来说,拷贝了数据到内核层就算完成了写操作了,但实际内核这个时候可能还没有把数据真正把数据送到目的地,真正的把数据送出去是内核再通过调度在合适的时间发送.所以可能存在极端情况,在这个间隙发生事故,应用层以为已经操作已经写完了,而实际上内核并没有完成使命.(这是我的理解~_~!)

## 阻塞与非阻塞
阻塞与非阻塞是应用层调用内核层时的概念,当应用层调用一个内核层接口,而此时内核层并没有准备好这个接口要调用的内容,此时内核层可以选择直接返回告诉应用层没有准备好,或者阻塞一直等到内核层准备好了再回复给应用层.
+ 阻塞  
当内核一直等到数据准备好时再回复给应用层,就称为阻塞;
+ 非阻塞  
当内核立刻回复应用层数据没有准备好,就称为非阻塞;此时需要应用层反复调用内核层api来确认内核是否准备好.直到有一次内核准备好,开始执行要做的操作,在执行操作的这段时间,应用层仍然是阻塞的.

## 异步与同步
异步与同步是内核通知应用层操作完成情况的方式.
+ 同步  
内核执行操作,直到操作完成后,把结果返回给应用层;
+ 异步  
内核得到执行操作的请求,返回给应用层表示会执行这个操作,让应用层先去干别的事情,内核层操作完成后会用别的方式通知应用层;

## IO复用,select(poll)与epoll
IO复用本质还是一种同步IO;  
前面的阻塞与非阻塞介绍了应用层调用内核层接口时会先询问内核层是否已经准备好.如果内核没有准备好,内核会返回没有准备好.如果内核已经准备好,则内核执行操作,然后返回操作结果.
IO复用就是应用层一次性询问多个请求是否准备好,然后内核返回已经准备好的请求,应用层再调一次内核api处理这些已经准备好的请求;  

IO复用自己本身就是由内核提供的一系列接口.
### select 与 poll
poll在select的基础上有改进,但核心机制没有改变,所以放一起. 

1. 应用层首先把要操作(读,写)的socket监听列表发给内核层.  
>这个过程是阻塞的,涉及到内存由应用层拷贝到内核层,当要操作的socket监听列表很大时,这里耗时也相应增大;  

2. 内核层遍历socket监听列表,找到已经准备好的socket,并作标记,然后把整个socket监听列表返回给应用层;

3. 应用层选择对这些已经做好标记的socket作处理.

这种方式存在的问题是socket监听列表在应用层和内核层之间的大量拷贝,开销很大;

### epoll
epoll是linux的一种新的多路IO复用方法.

1. 首先应用层发送请求在内核层建立一个socket监听事件列表;

2. 根据需要加入要监听的socket事件;  
>在这一步仍然需要把整个socket监听列表从应用层拷贝到内核层.

3. 应用层询问内核层哪些socket已经准备好,内核层会把已经准备好的socket放在一个列表里,然后返回给应用层;  
>注:这里只返回了已经准备好的socket

4. 应用层对已经准备好的socket做处理.

### 多路复用小结
由上可知epoll相对于poll(select)的优点:  
1. 更少的从应用层拷贝socket监听事件列表到内核层,尤其是同一个连接需要进行多次交互的情况;

2. 更少的从内核层拷贝数据到应用层,因为只拷贝了已经准备就绪的socket列表;而在实际的大多数应用场景中,大部分时间,大部分socket都是出于未就绪状态;

## 小结
现在一般运行在linux上的nginx都是选择epoll作IO复用,而apache选择的是select(poll);我想这应该是在很多应用场景中apache不如nginx支持高并发的原因.

