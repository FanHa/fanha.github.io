### 红黑树规则
+ 节点为红或者黑;
+ 根节点为黑;
+ 叶子节点为黑;
+ 连续两个节点不能都为红;
+ 从任意节点出发到它每个叶子节点的黑色节点数相等;
---

### 节点结构
```伪代码
struct node {
    attr key,
    attr color,
    node *parent,
    node *leftChild,
    node *rightChild,

    function sibling,
    function isLeftChild,
    function isRightChild
}
```
叶子节点可以看作是个color为BLACK,key,leftChild,rightChild 都为NULL的节点;

### 查询
查询就是普通的二叉树查询,这里假设比当前节点小的在左子树,根当前节点大的在右子树;
```伪代码
function search(root, key){
    // 检验new的key的有效性
    *current = root;
    while( current->key != NULL){
        if(key < current->key){
            current = current->leftChild;
        } else if(key > current->key){
            current = current->rightChild;
        } else {
            return current;
        }    
    }
    // 这里key为NULL时返回节点而不是NULL是为了后面插入时定位到要插入的位置
    return current;
}
```

### 插入
插入先找到要插入的位置,然后再根据需要对树做调整,使满足红黑树特性
```伪代码
function insert(root, key){
    *current = search(root, key);
    if(current->key){
        // 已存在该值,错误处理
    }
    // createNewLeafNode用来初始化一个新的叶子节点,参数是该叶子节点的父节点
    current->leftChild = createNewLeafNode(current);
    current->rightChild = createNewLeafNode(current);
    current->key = key;
    current->color = RED;

    // 新插入的节点是黑色的,此时从当前节点往下的路径黑色,比其他的路径黑色要+1,会违反第五条特性“从任意节点出发到它每个叶子节点的黑色节点数相等”,需要裁剪;
    doTrim(current);
}

function doTrim(current){
    if(current->parent == NULL){
        current->color = BLACK;
        return;
    }
    if(current->parent->color == BLACK){
        return;
    } else { // current->parent->color == RED
        if(current->parent->sibling->color == RED){
            current->parent->color = BLACK;
            current->parent->sibling->color = BLACK;
            current->parent->parent->color = RED;
            current = current->parent->parent;
            doTrim(current);
            return;
        } else {// current->parent->sibling->color == BLACK    
            if(current->isLeftChild) {
                if(current->parent->isLeftChild){
                    center = current->parent->parent;
                    right_rotate(&center);
                    center->color = BLACK;
                    center->rightChild->color = RED;
                    return;
                } else {// current->parent->isRightChild
                    center = current->parent;
                    right_rotate(&center);
                    center = center->parent;
                    left_rotate(&center);
                    center->color = BLACK;
                    center>leftChild = RED;
                    return;
                }
            } else {// current->isRightChild
                if(current->parent->isLeftChild){
                    center = current->parent;
                    left_rotate(&center);
                    center = center->parent;
                    right_rotate(&center);
                    center->color = BLACK;
                    center->rightChild->color = RED;
                    return;
                } else {// current->parent->isRightChild
                    center = current->parent->parent;
                    left_rotate(&center)
                    center->color = BLACK;
                    center->leftChild = RED;
                    return;
                }
            }
        }
    }
}

function right_rotate(&center){
    oldCenter = center;
    oldCenterParent = center->parent;
    isOldCenterLeftChild = (center->parent->leftChild == center);
    oldLeftChild = center->leftChild;
    oldLeftChildRightChild = center->leftChild->rightChild;

    oldCenter->leftChild = oldLeftChildRightChild;
    oldCenter->parent = oldLeftChild;

    oldLeftChild->rightChild = oldCenter;
    oldLeftChild->parent = oldCenterParent;

    oldLeftChildRightChild->parent = oldCenter;

    if(isOldCenterParentLeftChild){
        oldCenterParent->leftChild = oldLeftChild;
    } else {
        oldCenterParent->rightChild = oldLeftChild;
    }

    center = oldLeftChild;
    
}

function left_rotate(center){
    // 镜像一下上面的right_rotate
}
```